101. Symmetric Tree
Steps:
(1) See if the tree is null
(2) Initiate a queue(FIFO), push left child and right child into the queue
(3) While queue is not empty (We still have nodes that are going to be compared), pop up the first two nodes
    4 conditions here:
      (1) Both are null                                             -- Continue
      (2) One null and one not null                                 -- Return false
      (3) Both NOT null -- Their values are not the same            -- Return false
                        -- Their values are the same                -- Go to Step (4)

(4) ORDER MATTERS
    queue.offer(left.left);
    queue.offer(right.right);
    queue.offer(left.right);
    queue.offer(right.left);
    
    In the same level, always push nth from the front and nth from the back into the queue at the same time.
    

103. Binary Tree Zigzag Level Order Traversal
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],

    3                    level 1
   / \
  9  20                  level 2
    /  \
   15   7                level 3
  /  \  /\
 1    2 3 4
[
  [3],
  [20,9],
  [15,7]
]

Algorithm:
1. Two stacks, stack1 for even levels, stack2 for odd levels
2. push level2 nodes into stack1 from LEFT to RIGHT (EVEN Level)
3. while stack1 or stack 2 is not empty
4.    For Even Level(nodes stored in stack 1)
         if current node is not empty, push its cihldren into stack2 from RIGHT to LEFT(ODD Level)
         New ArrayList to store node.val for even level
5.    For Odd Level (nodes stored in stack 2)
         if current node is not empty, push its children into stack2 from LEFT to RIGHT(EVEN Level)
         New ArrayList to store node.val for odd level

You can simplify further:
Push root into stack2, Then go into while loop

My Thought Flow:
First consider using QUEUE and STACK for each adjacent level, because adjacent level has opposite order, 
from right to left, then from left to right

The Problem is:
1. If Push Level 2 Nodes into Stack from LEFT to RIGHT, then Node 20 will come out first, and when you push its children,
   If you push level 3 nodes into queue, it's wrong
   If you push level 3 nodes into stack from right to left, then level 3 is okay, let's examine level 4, also okay
   Use Stack Only
   
2. If Push Level 2 Nodes into Queue from RIGHT to LEFT, again, the Node 20 will come out first, when pushing its children,
   To make sure Level 3 Nodes from LEFT to RIGHT, have to use stack, and push from right child to left child;
   Then In your stack, you have | 15|   for level 3
                                |---|
                                | 7 |
                               
   For level 4, the order is from RIGHT to LEFT, Again you have to use stack to place level 4 nodes, children of level 3
   
So, in one word, no matter what you use for level 2, you have to use stacks for following levels, 
Therefore, use stacks for consistency. 
Use stack1 for even levels, stack2 for odd levels. 


301. Remove Invalid Parentheses
Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

Note: The input string may contain letters other than the parentheses ( and ).

Examples:
"()())()" -> ["()()()", "(())()"]
"(a)())()" -> ["(a)()()", "(a())()"]
")(" -> [""]

ENUMERATION, loops over all possible conditions before deleting certain numbers of '(' / ')'
NOTICE that: It is possible that you may need to delete more than 1 '('/')'. If you are deleting the nth '('/')', it must come from the
string that you have deleted (n-1) '('/')'s. Therefore, we can create a queue to store all the strings, while queue is not empty, poll 
out a string each time, decide if it's a valid string, if yes, stop deleting more '('/')'.

Algorithm:
1. offer string into queue,
2. while queue is not empty, 
   (1) poll head of queue
   (2) judge if current string is valid or not
   (3) if it is valid, stop deleting from current string and other strings in queue
   (4) if it is not valid, deleting one more ( or ) from current string
             if no other such string has appeared, save it
             (push it into queue and visied hash table)
3. Finish looping, return result.












