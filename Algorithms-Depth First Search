116. Populating Next Right Pointers in Each Node

Note:

You may only use constant extra space.
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).

         1                    
       /  \
      2    3
     / \  / \
    4  5  6  7     
    
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL
    
Algorithm:
leftEnd -> leftmost node within each level
current -> loop through all nodes in current level

while (leftEnd is not leaf) {
    current = leftEnd;    // reset current at the beginning of each loop;
    while (current node is not null) {
        current.left.next = current.right;
        current.right.next: depending on whether current.next is null or not;
        current = current.next;
    }
    // current level finishes
    // go to next level
    leftEnd = leftEnd.left;
}
// reach leaf, exit loop


257. Binary Tree Paths
Inout:
    1
  /   \
 2     3
  \
   5
  
Return:
["1->2->5", "1->3"]

Algorithm:
bottom up
if (root == null) 
    return [];
if (root is leaf);
    return ["root.val"];
for (each string in left children paths) {
    add to current paths;
}
for (each string in right children paths) {
    add to current paths;
}
return path;

