279. Perfect Squares
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.
For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.

For a given number, n, if it's not a square number, the following statement must be true:
dp(n) = d(n - j * j) + 1

which means it is the sum of another number and a square number
And there might be multiply combinations, we should pick the least number
Reverse back, why start from 1 to n, calculate the least square sum for each one and store it in an array, until n

Algorithm:
1. Initiate an array myArray[n+1], set each element within it to Integer.MAX_VALUE;
2. loop Outer:
   i: from i to n
3. loop Inner:
   j : from 1 to i + j * j <= n
4. store minimum:
   myArray[i + j * j] = min(myArray[i] + 1, myArray[i + j * j])
5. return myArray[n]

The two loops make sure the algorithm tranverse all numbers between 1 and n


103. Binary Tree Zigzag Level Order Traversal
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],

    3                    level 1
   / \
  9  20                  level 2
    /  \
   15   7                level 3
  /  \  /\
 1    2 3 4
[
  [3],
  [20,9],
  [15,7]
]

Algorithm:
1. Two stacks, stack1 for even levels, stack2 for odd levels
2. push level2 nodes into stack1 from LEFT to RIGHT (EVEN Level)
3. while stack1 or stack 2 is not empty
4.    For Even Level(nodes stored in stack 1)
         if current node is not empty, push its cihldren into stack2 from RIGHT to LEFT(ODD Level)
         New ArrayList to store node.val for even level
5.    For Odd Level (nodes stored in stack 2)
         if current node is not empty, push its children into stack2 from LEFT to RIGHT(EVEN Level)
         New ArrayList to store node.val for odd level

You can simplify further:
Push root into stack2, Then go into while loop

My Thought Flow:
First consider using QUEUE and STACK for each adjacent level, because adjacent level has opposite order, 
from right to left, then from left to right

The Problem is:
1. If Push Level 2 Nodes into Stack from LEFT to RIGHT, then Node 20 will come out first, and when you push its children,
   If you push level 3 nodes into queue, it's wrong
   If you push level 3 nodes into stack from right to left, then level 3 is okay, let's examine level 4, also okay
   Use Stack Only
   
2. If Push Level 2 Nodes into Queue from RIGHT to LEFT, again, the Node 20 will come out first, when pushing its children,
   To make sure Level 3 Nodes from LEFT to RIGHT, have to use stack, and push from right child to left child;
   Then In your stack, you have | 15|   for level 3
                                |---|
                                | 7 |
                               
   For level 4, the order is from RIGHT to LEFT, Again you have to use stack to place level 4 nodes, children of level 3
   
So, in one word, no matter what you use for level 2, you have to use stacks for following levels, 
Therefore, use stacks for consistency. 
Use stack1 for even levels, stack2 for odd levels. 
   



